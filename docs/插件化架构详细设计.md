# Claude 桌面宠物 - 插件化架构详细设计

**版本**: v3.1
**更新**: 2026-02-04

---

## 一、插件设计规范

### 1.1 插件分类

根据检测方式，插件分为三种类型：

| 类型 | 检测方式 | 示例 |
|------|----------|------|
| **ProcessPlugin** | 进程 CPU/内存 | Claude Code、OpenCode、Cursor |
| **WindowPlugin** | 窗口标题/文本 | 终端、IDE、聊天软件 |
| **FilePlugin** | 文件变更 | Git 操作、文件同步 |
| **HttpPlugin** | HTTP API | Web 服务状态 |
| **CustomPlugin** | 组合检测 | 自定义逻辑 |

### 1.2 插件接口设计

#### 核心接口（所有插件必须实现）

```python
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List
from dataclasses import dataclass, field
from enum import Enum
import time
import asyncio


class Status(Enum):
    """统一状态枚举"""
    UNKNOWN = "unknown"
    IDLE = "idle"
    RUNNING = "running"
    WORKING = "working"
    THINKING = "thinking"
    EXECUTING = "executing"
    ERROR = "error"
    STOPPED = "stopped"


@dataclass
class StateEvent:
    """状态事件"""
    plugin_name: str
    status: Status
    confidence: float  # 0.0 - 1.0
    details: Dict[str, Any] = field(default_factory=dict)
    timestamp: float = field(default_factory=time.time)


class DetectionMethod(Enum):
    """检测方法枚举"""
    PROCESS = "process"      # 进程监控
    WINDOW = "window"        # 窗口监控
    FILE = "file"           # 文件监控
    HTTP = "http"           # HTTP API
    CUSTOM = "custom"       # 自定义


class PluginMetadata:
    """插件元信息"""
    name: str
    version: str
    description: str
    author: str
    detection_method: DetectionMethod
    capabilities: List[str] = field(default_factory=list)  # 如 ["cpu", "memory", "network"]
    dependencies: List[str] = field(default_factory=list)  # 外部依赖


class BasePlugin(ABC):
    """插件基类"""
    
    # 插件元信息（子类必须设置）
    metadata: PluginMetadata
    
    def __init__(self, config: Dict = None):
        self.config = config or {}
        self.enabled = True
        self.running = False
        self.middleware = None
        self.logger = None
    
    # ========== 必须实现 ==========
    
    @abstractmethod
    def check_available(self) -> bool:
        """检查目标是否可用"""
        pass
    
    @abstractmethod
    def detect(self) -> Optional[StateEvent]:
        """检测状态，返回状态事件或 None"""
        pass
    
    # ========== 可选实现 ==========
    
    def initialize(self, middleware, logger=None):
        """初始化"""
        self.middleware = middleware
        self.logger = logger
    
    def start(self):
        """插件启动（用于资源初始化）"""
        self.running = True
    
    def stop(self):
        """插件停止（用于资源清理）"""
        self.running = False
    
    def on_event(self, event: StateEvent):
        """接收其他插件的事件"""
        pass
    
    def get_config_schema(self) -> Dict:
        """返回配置 schema（用于配置验证）"""
        return {}
    
    def validate_config(self, config: Dict) -> bool:
        """验证配置"""
        return True
    
    # ========== 工具方法 ==========
    
    def publish(self, event: StateEvent):
        """发布事件到中间件"""
        if self.middleware:
            self.middleware.publish(event)
    
    def is_enabled(self) -> bool:
        return self.enabled
    
    def log_info(self, msg: str):
        if self.logger:
            self.logger.info(f"[{self.metadata.name}] {msg}")
    
    def log_error(self, msg: str):
        if self.logger:
            self.logger.error(f"[{self.metadata.name}] {msg}")
```

### 1.3 插件模板示例

#### 进程检测模板

```python
# plugins/process_template.py
from typing import Dict
from src.plugins.base import (
    BasePlugin, Status, StateEvent, DetectionMethod, PluginMetadata
)


class ProcessMonitorPlugin(BasePlugin):
    """
    进程监控插件模板
    
    适用于：通过进程名称检测运行状态的软件
    如：Claude Code、OpenCode、Cursor 等
    """
    
    # 插件元信息
    metadata = PluginMetadata(
        name="process_template",
        version="1.0.0",
        description="进程监控插件模板",
        author="Claude",
        detection_method=DetectionMethod.PROCESS,
        capabilities=["cpu", "memory"]
    )
    
    def __init__(self, config: Dict = None):
        super().__init__(config)
        
        # 配置项（可从 config 覆盖）
        self.process_names = config.get("process_names", [])  # 如 ["claude.exe"]
        self.cpu_thresholds = config.get("cpu_thresholds", {
            "idle": 0.5,
            "running": 5.0,
            "thinking": 15.0,
            "busy": 50.0,
        })
    
    def check_available(self) -> bool:
        """检查目标进程是否存在"""
        import psutil
        for proc in psutil.process_iter(['name']):
            try:
                if proc.info['name'] in self.process_names:
                    return True
            except:
                pass
        return False
    
    def detect(self) -> Optional[StateEvent]:
        """检测进程状态"""
        import psutil
        
        total_cpu = 0.0
        total_memory = 0.0
        process_count = 0
        
        for proc in psutil.process_iter(['name', 'cpu_percent', 'memory_info']):
            try:
                if proc.info['name'] in self.process_names:
                    total_cpu += proc.info.get('cpu_percent', 0)
                    mem = proc.info.get('memory_info')
                    if mem:
                        total_memory += mem.rss / 1024 / 1024  # MB
                    process_count += 1
            except:
                pass
        
        if process_count == 0:
            return None  # 进程不存在
        
        # 根据 CPU 判断状态
        if total_cpu < self.cpu_thresholds["idle"]:
            status = Status.IDLE
        elif total_cpu < self.cpu_thresholds["running"]:
            status = Status.RUNNING
        elif total_cpu < self.cpu_thresholds["thinking"]:
            status = Status.THINKING
        elif total_cpu < self.cpu_thresholds["busy"]:
            status = Status.WORKING
        else:
            status = Status.EXECUTING
        
        # 计算置信度
        confidence = min(0.95, 0.5 + (total_cpu / 100) * 0.4)
        
        return StateEvent(
            plugin_name=self.metadata.name,
            status=status,
            confidence=confidence,
            details={
                "cpu_percent": total_cpu,
                "memory_mb": total_memory,
                "process_count": process_count,
            }
        )
```

#### 窗口检测模板

```python
# plugins/window_template.py
from typing import Dict, List, Pattern
import re
from src.plugins.base import (
    BasePlugin, Status, StateEvent, DetectionMethod, PluginMetadata
)


class WindowMonitorPlugin(BasePlugin):
    """
    窗口监控插件模板
    
    适用于：通过窗口标题或文本检测状态的软件
    如：终端、IDE、聊天软件等
    """
    
    metadata = PluginMetadata(
        name="window_template",
        version="1.0.0",
        description="窗口监控插件模板",
        author="Claude",
        detection_method=DetectionMethod.WINDOW,
        capabilities=["title", "text"]
    )
    
    def __init__(self, config: Dict = None):
        super().__init__(config)
        
        self.window_titles = config.get("window_titles", [])  # 窗口标题关键词
        self.status_patterns = config.get("status_patterns", {
            Status.THINKING: [r"thinking", r"思考"],
            Status.EXECUTING: [r"bash", r"npm", r"pip", r"running"],
            Status.WORKING: [r"edit", r"write", r"save"],
            Status.DONE: [r"done", r"complete", r"success"],
            Status.ERROR: [r"error", r"fail", r"exception"],
        })
    
    def check_available(self) -> bool:
        """检查目标窗口是否存在"""
        try:
            import pygetwindow
            all_windows = pygetwindow.getAllTitles()
            for title in all_windows:
                for keyword in self.window_titles:
                    if keyword.lower() in title.lower():
                        return True
        except:
            pass
        return False
    
    def detect(self) -> Optional[StateEvent]:
        """检测窗口状态"""
        try:
            import pygetwindow
            all_windows = pygetwindow.getAllTitles()
            
            # 查找匹配的窗口
            matched_windows = []
            for title in all_windows:
                for keyword in self.window_titles:
                    if keyword.lower() in title.lower():
                        matched_windows.append(title)
                        break
            
            if not matched_windows:
                return None
            
            # 分析窗口标题获取状态
            status = self._analyze_title(matched_windows[0])
            confidence = 0.7  # 窗口检测置信度
            
            return StateEvent(
                plugin_name=self.metadata.name,
                status=status,
                confidence=confidence,
                details={
                    "windows": matched_windows,
                    "primary_window": matched_windows[0],
                }
            )
        except Exception as e:
            self.log_error(f"检测失败: {e}")
            return None
    
    def _analyze_title(self, title: str) -> Status:
        """分析窗口标题推断状态"""
        title_lower = title.lower()
        
        # 按优先级检查
        priority = [
            (Status.ERROR, self.status_patterns.get(Status.ERROR, [])),
            (Status.DONE, self.status_patterns.get(Status.DONE, [])),
            (Status.EXECUTING, self.status_patterns.get(Status.EXECUTING, [])),
            (Status.WORKING, self.status_patterns.get(Status.WORKING, [])),
            (Status.THINKING, self.status_patterns.get(Status.THINKING, [])),
        ]
        
        for status, patterns in priority:
            for pattern in patterns:
                if re.search(pattern, title_lower):
                    return status
        
        return Status.RUNNING
```

### 1.4 插件通信机制

#### 插件与中间件的通信

```python
# 插件可以：
1. 发布事件到中间件
self.publish(StateEvent(...))

2. 订阅其他插件的事件
def on_other_event(self, event: StateEvent):
    # 处理其他插件的事件
    pass

# 在中间件中配置
middleware.subscribe("other_plugin", self.on_other_event)
```

#### 插件间通信（事件驱动）

```python
# 事件类型定义
class EventType:
    STATE_CHANGED = "state_changed"
    PLUGIN_ADDED = "plugin_added"
    PLUGIN_REMOVED = "plugin_removed"
    CONFIG_CHANGED = "config_changed"

# 发布事件
middleware.publish(Event(
    type=EventType.STATE_CHANGED,
    data={
        "plugin": self.metadata.name,
        "old_status": old_status,
        "new_status": new_status,
    }
))
```

---

## 二、输出模式设计

### 2.1 输出模式分类

| 模式 | 协议 | 适用场景 | 延迟 |
|------|------|----------|------|
| **WebSocket** | ws:// | 实时前端推送 | < 10ms |
| **HTTP REST** | http:// | 轮询获取状态 | 轮询间隔 |
| **Redis Pub/Sub** | redis:// | 多实例同步 | < 1ms |
| **Stdout** | stdout | 调试/CLI | 实时 |
| **MQTT** | mqtt:// | IoT 设备 | < 100ms |
| **WebHook** | http:// | 外部服务集成 | 网络延迟 |

### 2.2 输出适配器接口

```python
from abc import ABC, abstractmethod
from typing import Dict, Any


class OutputAdapter(ABC):
    """输出适配器基类"""
    
    def __init__(self, config: Dict = None):
        self.config = config or {}
        self.enabled = True
    
    @abstractmethod
    def connect(self):
        """建立连接"""
        pass
    
    @abstractmethod
    def send(self, event: StateEvent):
        """发送状态事件"""
        pass
    
    @abstractmethod
    def disconnect(self):
        """断开连接"""
        pass
    
    def is_connected(self) -> bool:
        return hasattr(self, '_connected') and self._connected
```

### 2.3 WebSocket 适配器（实时推送）

```python
import asyncio
import json
from websockets.asyncio.server import serve, broadcast


class WebSocketAdapter(OutputAdapter):
    """WebSocket 输出适配器"""
    
    def __init__(self, config: Dict = None):
        super().__init__(config)
        self.host = self.config.get("host", "127.0.0.1")
        self.port = self.config.get("port", 8765)
        self.clients = set()
        self.server = None
    
    def connect(self):
        asyncio.run(self._start_server())
    
    async def _start_server(self):
        async def handler(websocket):
            self.clients.add(websocket)
            self.log_info(f"客户端连接，当前: {len(self.clients)}")
            try:
                async for _ in websocket:
                    pass
            finally:
                self.clients.remove(websocket)
        
        self.server = serve(handler, self.host, self.port)
        self._connected = True
        self.log_info(f"WebSocket 服务器启动: ws://{self.host}:{self.port}")
        
        async with self.server:
            await asyncio.Future()  # 保持运行
    
    def send(self, event: StateEvent):
        if not self.clients:
            return
        
        message = json.dumps({
            "plugin": event.plugin_name,
            "status": event.status.value,
            "confidence": event.confidence,
            "details": event.details,
            "timestamp": event.timestamp,
        })
        
        # 并发广播到所有客户端
        disconnected = []
        for client in self.clients:
            try:
                asyncio.run(client.send(message))
            except:
                disconnected.append(client)
        
        for client in disconnected:
            self.clients.discard(client)
    
    def disconnect(self):
        if self.server:
            self.server.close()
        self._connected = False
```

### 2.4 HTTP REST 适配器（轮询获取）

```python
from flask import Flask, jsonify


class HTTPAdapter(OutputAdapter):
    """HTTP REST 输出适配器"""
    
    def __init__(self, config: Dict = None):
        super().__init__(config)
        self.host = self.config.get("host", "127.0.0.1")
        self.port = self.config.get("port", 8080)
        self.middleware_ref = None
        self.app = Flask(__name__)
        self.thread = None
    
    def connect(self, middleware):
        self.middleware_ref = middleware
        self._setup_routes()
        self.thread = threading.Thread(target=self._run_flask, daemon=True)
        self.thread.start()
        self._connected = True
    
    def _setup_routes(self):
        @self.app.route("/api/state")
        def get_state():
            return jsonify(self.middleware_ref.get_fused_state().__dict__)
        
        @self.app.route("/api/states")
        def get_all_states():
            return jsonify({
                name: event.__dict__
                for name, event in self.middleware_ref.get_all_states().items()
            })
        
        @self.app.route("/api/plugins")
        def get_plugins():
            return jsonify({
                "plugins": list(self.middleware_ref.plugins.keys())
            })
    
    def _run_flask(self):
        self.app.run(host=self.host, port=self.port, threaded=True)
    
    def send(self, event: StateEvent):
        # HTTP 是被动获取，不需要主动发送
        pass
    
    def disconnect(self):
        import os
        os._exit(0)  # 简单粗暴的退出
```

### 2.5 Redis Pub/Sub 适配器（多实例同步）

```python
import redis
import json
import threading


class RedisAdapter(OutputAdapter):
    """Redis Pub/Sub 输出适配器"""
    
    def __init__(self, config: Dict = None):
        super().__init__(config)
        self.channel = self.config.get("channel", "claude:status")
        self.redis_url = self.config.get("url", "redis://localhost:6379")
        self.pubsub = None
        self.publisher = None
        self.thread = None
        self.running = False
    
    def connect(self):
        self.publisher = redis.from_url(self.redis_url)
        self.pubsub = self.publisher.pubsub()
        self.pubsub.subscribe(self.channel)
        self.running = True
        
        # 后台接收消息（用于测试）
        self.thread = threading.Thread(target=self._listen, daemon=True)
        self.thread.start()
        
        self._connected = True
    
    def _listen(self):
        for message in self.pubsub.listen():
            if not self.running:
                break
            if message['type'] == 'message':
                self.log_info(f"收到消息: {message['data']}")
    
    def send(self, event: StateEvent):
        if not self.publisher:
            return
        
        message = json.dumps({
            "plugin": event.plugin_name,
            "status": event.status.value,
            "confidence": event.confidence,
            "details": event.details,
            "timestamp": event.timestamp,
        })
        
        self.publisher.publish(self.channel, message)
    
    def disconnect(self):
        self.running = False
        if self.pubsub:
            self.pubsub.unsubscribe()
            self.pubsub.close()
        self._connected = False
```

### 2.6 统一输出格式

```python
# 所有输出适配器使用统一的 JSON 格式

{
    "event": "state_change",
    "data": {
        "plugin": "claude_code",
        "status": "thinking",
        "confidence": 0.85,
        "details": {
            "cpu_percent": 12.5,
            "memory_mb": 256.0
        },
        "fusion": {
            "overall_status": "thinking",
            "overall_confidence": 0.72
        }
    },
    "timestamp": 1700000000.123
}

# 错误事件
{
    "event": "error",
    "data": {
        "plugin": "claude_code",
        "error": "进程不存在",
        "timestamp": 1700000000.456
    }
}

# 系统事件
{
    "event": "plugin_added",
    "data": {
        "plugin": "cursor",
        "timestamp": 1700000000.789
    }
}
```

---

## 三、插件开发指南

### 3.1 开发新插件的步骤

1. **确定检测方法**
   - 进程监控 → 继承 `ProcessMonitorPlugin`
   - 窗口监控 → 继承 `WindowMonitorPlugin`
   - 自定义 → 继承 `BasePlugin`

2. **实现必需方法**
   - `check_available()` - 检查目标是否可用
   - `detect()` - 检测状态

3. **配置元信息**
   - 设置 `metadata` 属性

4. **注册插件**
   - 手动注册或放入 `plugins/` 目录自动加载

### 3.2 插件配置示例

```json
{
  "plugins": {
    "claude_code": {
      "enabled": true,
      "process_names": ["claude.exe", "Claude Code.exe"],
      "cpu_thresholds": {
        "idle": 0.5,
        "running": 5.0,
        "thinking": 15.0,
        "busy": 50.0
      },
      "weight": 1.0
    },
    "opencode": {
      "enabled": true,
      "window_titles": ["OpenCode", "opencode"],
      "status_patterns": {
        "thinking": ["thinking", "思考"],
        "executing": ["bash", "npm", "python"]
      },
      "weight": 0.8
    }
  },
  
  "outputs": {
    "websocket": {
      "enabled": true,
      "host": "127.0.0.1",
      "port": 8765
    },
    "http": {
      "enabled": true,
      "host": "127.0.0.1",
      "port": 8080
    },
    "redis": {
      "enabled": false,
      "channel": "claude:status"
    }
  }
}
```

### 3.3 插件目录结构

```
plugins/
├── __init__.py
│
├── system/                    # 系统级插件
│   ├── __init__.py
│   ├── process_monitor.py    # 进程监控基类
│   ├── claude_code.py        # Claude Code
│   ├── opencode.py           # OpenCode
│   ├── cursor.py             # Cursor
│   ├── copilot.py            # GitHub Copilot
│   └── vscode.py             # VS Code
│
├── network/                   # 网络相关插件
│   ├── __init__.py
│   ├── http_status.py        # HTTP 服务状态
│   └── docker.py             # Docker 容器
│
├── custom/                    # 自定义插件模板
│   ├── __init__.py
│   └── template.py           # 插件模板
│
└── README.md                 # 插件开发指南
```

---

## 四、架构演进路线

### 阶段 1: MVP（当前）
- 基础插件接口
- WebSocket + HTTP 输出
- Claude Code + OpenCode 插件

### 阶段 2: 扩展
- 更多插件（Cursor、VS Code 等）
- Redis 输出适配器
- 插件配置热加载

### 阶段 3: 完善
- 插件市场/社区分享
- 插件沙箱（安全隔离）
- 云端配置同步

---

**文档版本**: v3.1
**最后更新**: 2026-02-04
