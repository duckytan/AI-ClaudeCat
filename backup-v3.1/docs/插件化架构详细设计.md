# Claude 桌面宠物 - 插件化架构详细设计

**版本**: v3.1
**更新**: 2026-02-04

---

## 一、插件设计规范

### 1.1 插件分类

根据检测方式，插件分为三种类型：

| 类型 | 检测方式 | 示例 |
|------|----------|------|
| **ProcessPlugin** | 进程 CPU/内存 | Claude Code、OpenCode、Cursor |
| **WindowPlugin** | 窗口标题/文本 | 终端、IDE、聊天软件 |
| **FilePlugin** | 文件变更 | Git 操作、文件同步 |
| **HttpPlugin** | HTTP API | Web 服务状态 |
| **CustomPlugin** | 组合检测 | 自定义逻辑 |

### 1.2 插件接口设计

#### 核心接口（所有插件必须实现）

```python
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List
from dataclasses import dataclass, field
from enum import Enum
import time
import asyncio


class Status(Enum):
    """统一状态枚举"""
    UNKNOWN = "unknown"
    IDLE = "idle"
    RUNNING = "running"
    WORKING = "working"
    THINKING = "thinking"
    EXECUTING = "executing"
    ERROR = "error"
    STOPPED = "stopped"


@dataclass
class StateEvent:
    """状态事件"""
    plugin_name: str
    status: Status
    confidence: float  # 0.0 - 1.0
    details: Dict[str, Any] = field(default_factory=dict)
    timestamp: float = field(default_factory=time.time)


class DetectionMethod(Enum):
    """检测方法枚举"""
    PROCESS = "process"      # 进程监控
    WINDOW = "window"        # 窗口监控
    FILE = "file"           # 文件监控
    HTTP = "http"           # HTTP API
    CUSTOM = "custom"       # 自定义


class PluginMetadata:
    """插件元信息"""
    name: str
    version: str
    description: str
    author: str
    detection_method: DetectionMethod
    capabilities: List[str] = field(default_factory=list)  # 如 ["cpu", "memory", "network"]
    dependencies: List[str] = field(default_factory=list)  # 外部依赖


class BasePlugin(ABC):
    """插件基类"""
    
    # 插件元信息（子类必须设置）
    metadata: PluginMetadata
    
    def __init__(self, config: Dict = None):
        self.config = config or {}
        self.enabled = True
        self.running = False
        self.middleware = None
        self.logger = None
    
    # ========== 必须实现 ==========
    
    @abstractmethod
    def check_available(self) -> bool:
        """检查目标是否可用"""
        pass
    
    @abstractmethod
    def detect(self) -> Optional[StateEvent]:
        """检测状态，返回状态事件或 None"""
        pass
    
    # ========== 可选实现 ==========
    
    def initialize(self, middleware, logger=None):
        """初始化"""
        self.middleware = middleware
        self.logger = logger
    
    def start(self):
        """插件启动（用于资源初始化）"""
        self.running = True
    
    def stop(self):
        """插件停止（用于资源清理）"""
        self.running = False
    
    def on_event(self, event: StateEvent):
        """接收其他插件的事件"""
        pass
    
    def get_config_schema(self) -> Dict:
        """返回配置 schema（用于配置验证）"""
        return {}
    
    def validate_config(self, config: Dict) -> bool:
        """验证配置"""
        return True
    
    # ========== 工具方法 ==========
    
    def publish(self, event: StateEvent):
        """发布事件到中间件"""
        if self.middleware:
            self.middleware.publish(event)
    
    def is_enabled(self) -> bool:
        return self.enabled
    
    def log_info(self, msg: str):
        if self.logger:
            self.logger.info(f"[{self.metadata.name}] {msg}")
    
    def log_error(self, msg: str):
        if self.logger:
            self.logger.error(f"[{self.metadata.name}] {msg}")
```

### 1.3 插件模板示例

#### 进程检测模板

```python
# plugins/process_template.py
from typing import Dict
from src.plugins.base import (
    BasePlugin, Status, StateEvent, DetectionMethod, PluginMetadata
)


class ProcessMonitorPlugin(BasePlugin):
    """
    进程监控插件模板
    
    适用于：通过进程名称检测运行状态的软件
    如：Claude Code、OpenCode、Cursor 等
    """
    
    # 插件元信息
    metadata = PluginMetadata(
        name="process_template",
        version="1.0.0",
        description="进程监控插件模板",
        author="Claude",
        detection_method=DetectionMethod.PROCESS,
        capabilities=["cpu", "memory"]
    )
    
    def __init__(self, config: Dict = None):
        super().__init__(config)
        
        # 配置项（可从 config 覆盖）
        self.process_names = config.get("process_names", [])  # 如 ["claude.exe"]
        self.cpu_thresholds = config.get("cpu_thresholds", {
            "idle": 0.5,
            "running": 5.0,
            "thinking": 15.0,
            "busy": 50.0,
        })
    
    def check_available(self) -> bool:
        """检查目标进程是否存在"""
        import psutil
        for proc in psutil.process_iter(['name']):
            try:
                if proc.info['name'] in self.process_names:
                    return True
            except:
                pass
        return False
    
    def detect(self) -> Optional[StateEvent]:
        """检测进程状态"""
        import psutil
        
        total_cpu = 0.0
        total_memory = 0.0
        process_count = 0
        
        for proc in psutil.process_iter(['name', 'cpu_percent', 'memory_info']):
            try:
                if proc.info['name'] in self.process_names:
                    total_cpu += proc.info.get('cpu_percent', 0)
                    mem = proc.info.get('memory_info')
                    if mem:
                        total_memory += mem.rss / 1024 / 1024  # MB
                    process_count += 1
            except:
                pass
        
        if process_count == 0:
            return None  # 进程不存在
        
        # 根据 CPU 判断状态
        if total_cpu < self.cpu_thresholds["idle"]:
            status = Status.IDLE
        elif total_cpu < self.cpu_thresholds["running"]:
            status = Status.RUNNING
        elif total_cpu < self.cpu_thresholds["thinking"]:
            status = Status.THINKING
        elif total_cpu < self.cpu_thresholds["busy"]:
            status = Status.WORKING
        else:
            status = Status.EXECUTING
        
        # 计算置信度
        confidence = min(0.95, 0.5 + (total_cpu / 100) * 0.4)
        
        return StateEvent(
            plugin_name=self.metadata.name,
            status=status,
            confidence=confidence,
            details={
                "cpu_percent": total_cpu,
                "memory_mb": total_memory,
                "process_count": process_count,
            }
        )
```

#### 窗口检测模板

```python
# plugins/window_template.py
from typing import Dict, List, Pattern
import re
from src.plugins.base import (
    BasePlugin, Status, StateEvent, DetectionMethod, PluginMetadata
)


class WindowMonitorPlugin(BasePlugin):
    """
    窗口监控插件模板
    
    适用于：通过窗口标题或文本检测状态的软件
    如：终端、IDE、聊天软件等
    """
    
    metadata = PluginMetadata(
        name="window_template",
        version="1.0.0",
        description="窗口监控插件模板",
        author="Claude",
        detection_method=DetectionMethod.WINDOW,
        capabilities=["title", "text"]
    )
    
    def __init__(self, config: Dict = None):
        super().__init__(config)
        
        self.window_titles = config.get("window_titles", [])  # 窗口标题关键词
        self.status_patterns = config.get("status_patterns", {
            Status.THINKING: [r"thinking", r"思考"],
            Status.EXECUTING: [r"bash", r"npm", r"pip", r"running"],
            Status.WORKING: [r"edit", r"write", r"save"],
            Status.DONE: [r"done", r"complete", r"success"],
            Status.ERROR: [r"error", r"fail", r"exception"],
        })
    
    def check_available(self) -> bool:
        """检查目标窗口是否存在"""
        try:
            import pygetwindow
            all_windows = pygetwindow.getAllTitles()
            for title in all_windows:
                for keyword in self.window_titles:
                    if keyword.lower() in title.lower():
                        return True
        except:
            pass
        return False
    
    def detect(self) -> Optional[StateEvent]:
        """检测窗口状态"""
        try:
            import pygetwindow
            all_windows = pygetwindow.getAllTitles()
            
            # 查找匹配的窗口
            matched_windows = []
            for title in all_windows:
                for keyword in self.window_titles:
                    if keyword.lower() in title.lower():
                        matched_windows.append(title)
                        break
            
            if not matched_windows:
                return None
            
            # 分析窗口标题获取状态
            status = self._analyze_title(matched_windows[0])
            confidence = 0.7  # 窗口检测置信度
            
            return StateEvent(
                plugin_name=self.metadata.name,
                status=status,
                confidence=confidence,
                details={
                    "windows": matched_windows,
                    "primary_window": matched_windows[0],
                }
            )
        except Exception as e:
            self.log_error(f"检测失败: {e}")
            return None
    
    def _analyze_title(self, title: str) -> Status:
        """分析窗口标题推断状态"""
        title_lower = title.lower()
        
        # 按优先级检查
        priority = [
            (Status.ERROR, self.status_patterns.get(Status.ERROR, [])),
            (Status.DONE, self.status_patterns.get(Status.DONE, [])),
            (Status.EXECUTING, self.status_patterns.get(Status.EXECUTING, [])),
            (Status.WORKING, self.status_patterns.get(Status.WORKING, [])),
            (Status.THINKING, self.status_patterns.get(Status.THINKING, [])),
        ]
        
        for status, patterns in priority:
            for pattern in patterns:
                if re.search(pattern, title_lower):
                    return status
        
        return Status.RUNNING
```

### 1.4 插件通信机制

#### 插件与中间件的通信

```python
# 插件可以：
1. 发布事件到中间件
self.publish(StateEvent(...))

2. 订阅其他插件的事件
def on_other_event(self, event: StateEvent):
    # 处理其他插件的事件
    pass

# 在中间件中配置
middleware.subscribe("other_plugin", self.on_other_event)
```

#### 插件间通信（事件驱动）

```python
# 事件类型定义
class EventType:
    STATE_CHANGED = "state_changed"
    PLUGIN_ADDED = "plugin_added"
    PLUGIN_REMOVED = "plugin_removed"
    CONFIG_CHANGED = "config_changed"

# 发布事件
middleware.publish(Event(
    type=EventType.STATE_CHANGED,
    data={
        "plugin": self.metadata.name,
        "old_status": old_status,
        "new_status": new_status,
    }
))
```

---

## 二、输出模式设计

### 2.1 输出模式分类

| 模式 | 协议 | 适用场景 | 延迟 |
|------|------|----------|------|
| **WebSocket** | ws:// | 实时前端推送 | < 10ms |
| **HTTP REST** | http:// | 轮询获取状态 | 轮询间隔 |
| **Redis Pub/Sub** | redis:// | 多实例同步 | < 1ms |
| **Stdout** | stdout | 调试/CLI | 实时 |
| **MQTT** | mqtt:// | IoT 设备 | < 100ms |
| **WebHook** | http:// | 外部服务集成 | 网络延迟 |

### 2.2 输出适配器接口

```python
from abc import ABC, abstractmethod
from typing import Dict, Any


class OutputAdapter(ABC):
    """输出适配器基类"""
    
    def __init__(self, config: Dict = None):
        self.config = config or {}
        self.enabled = True
    
    @abstractmethod
    def connect(self):
        """建立连接"""
        pass
    
    @abstractmethod
    def send(self, event: StateEvent):
        """发送状态事件"""
        pass
    
    @abstractmethod
    def disconnect(self):
        """断开连接"""
        pass
    
    def is_connected(self) -> bool:
        return hasattr(self, '_connected') and self._connected
```

### 2.3 WebSocket 适配器（实时推送）

```python
import asyncio
import json
from websockets.asyncio.server import serve, broadcast


class WebSocketAdapter(OutputAdapter):
    """WebSocket 输出适配器"""
    
    def __init__(self, config: Dict = None):
        super().__init__(config)
        self.host = self.config.get("host", "127.0.0.1")
        self.port = self.config.get("port", 8765)
        self.clients = set()
        self.server = None
    
    def connect(self):
        asyncio.run(self._start_server())
    
    async def _start_server(self):
        async def handler(websocket):
            self.clients.add(websocket)
            self.log_info(f"客户端连接，当前: {len(self.clients)}")
            try:
                async for _ in websocket:
                    pass
            finally:
                self.clients.remove(websocket)
        
        self.server = serve(handler, self.host, self.port)
        self._connected = True
        self.log_info(f"WebSocket 服务器启动: ws://{self.host}:{self.port}")
        
        async with self.server:
            await asyncio.Future()  # 保持运行
    
    def send(self, event: StateEvent):
        if not self.clients:
            return
        
        message = json.dumps({
            "plugin": event.plugin_name,
            "status": event.status.value,
            "confidence": event.confidence,
            "details": event.details,
            "timestamp": event.timestamp,
        })
        
        # 并发广播到所有客户端
        disconnected = []
        for client in self.clients:
            try:
                asyncio.run(client.send(message))
            except:
                disconnected.append(client)
        
        for client in disconnected:
            self.clients.discard(client)
    
    def disconnect(self):
        if self.server:
            self.server.close()
        self._connected = False
```

### 2.4 HTTP REST 适配器（轮询获取）

```python
from flask import Flask, jsonify


class HTTPAdapter(OutputAdapter):
    """HTTP REST 输出适配器"""
    
    def __init__(self, config: Dict = None):
        super().__init__(config)
        self.host = self.config.get("host", "127.0.0.1")
        self.port = self.config.get("port", 8080)
        self.middleware_ref = None
        self.app = Flask(__name__)
        self.thread = None
    
    def connect(self, middleware):
        self.middleware_ref = middleware
        self._setup_routes()
        self.thread = threading.Thread(target=self._run_flask, daemon=True)
        self.thread.start()
        self._connected = True
    
    def _setup_routes(self):
        @self.app.route("/api/state")
        def get_state():
            return jsonify(self.middleware_ref.get_fused_state().__dict__)
        
        @self.app.route("/api/states")
        def get_all_states():
            return jsonify({
                name: event.__dict__
                for name, event in self.middleware_ref.get_all_states().items()
            })
        
        @self.app.route("/api/plugins")
        def get_plugins():
            return jsonify({
                "plugins": list(self.middleware_ref.plugins.keys())
            })
    
    def _run_flask(self):
        self.app.run(host=self.host, port=self.port, threaded=True)
    
    def send(self, event: StateEvent):
        # HTTP 是被动获取，不需要主动发送
        pass
    
    def disconnect(self):
        import os
        os._exit(0)  # 简单粗暴的退出
```

### 2.5 Redis Pub/Sub 适配器（多实例同步）

```python
import redis
import json
import threading


class RedisAdapter(OutputAdapter):
    """Redis Pub/Sub 输出适配器"""
    
    def __init__(self, config: Dict = None):
        super().__init__(config)
        self.channel = self.config.get("channel", "claude:status")
        self.redis_url = self.config.get("url", "redis://localhost:6379")
        self.pubsub = None
        self.publisher = None
        self.thread = None
        self.running = False
    
    def connect(self):
        self.publisher = redis.from_url(self.redis_url)
        self.pubsub = self.publisher.pubsub()
        self.pubsub.subscribe(self.channel)
        self.running = True
        
        # 后台接收消息（用于测试）
        self.thread = threading.Thread(target=self._listen, daemon=True)
        self.thread.start()
        
        self._connected = True
    
    def _listen(self):
        for message in self.pubsub.listen():
            if not self.running:
                break
            if message['type'] == 'message':
                self.log_info(f"收到消息: {message['data']}")
    
    def send(self, event: StateEvent):
        if not self.publisher:
            return
        
        message = json.dumps({
            "plugin": event.plugin_name,
            "status": event.status.value,
            "confidence": event.confidence,
            "details": event.details,
            "timestamp": event.timestamp,
        })
        
        self.publisher.publish(self.channel, message)
    
    def disconnect(self):
        self.running = False
        if self.pubsub:
            self.pubsub.unsubscribe()
            self.pubsub.close()
        self._connected = False
```

### 2.6 统一输出格式

```python
# 所有输出适配器使用统一的 JSON 格式

{
    "event": "state_change",
    "data": {
        "plugin": "claude_code",
        "status": "thinking",
        "confidence": 0.85,
        "details": {
            "cpu_percent": 12.5,
            "memory_mb": 256.0
        },
        "fusion": {
            "overall_status": "thinking",
            "overall_confidence": 0.72
        }
    },
    "timestamp": 1700000000.123
}

# 错误事件
{
    "event": "error",
    "data": {
        "plugin": "claude_code",
        "error": "进程不存在",
        "timestamp": 1700000000.456
    }
}

# 系统事件
{
    "event": "plugin_added",
    "data": {
        "plugin": "cursor",
        "timestamp": 1700000000.789
    }
}
```

---

## 三、插件开发指南

### 3.1 开发新插件的步骤

1. **确定检测方法**
   - 进程监控 → 继承 `ProcessMonitorPlugin`
   - 窗口监控 → 继承 `WindowMonitorPlugin`
   - 自定义 → 继承 `BasePlugin`

2. **实现必需方法**
   - `check_available()` - 检查目标是否可用
   - `detect()` - 检测状态

3. **配置元信息**
   - 设置 `metadata` 属性

4. **注册插件**
   - 手动注册或放入 `plugins/` 目录自动加载

### 3.2 插件配置示例

```json
{
  "plugins": {
    "claude_code": {
      "enabled": true,
      "process_names": ["claude.exe", "Claude Code.exe"],
      "cpu_thresholds": {
        "idle": 0.5,
        "running": 5.0,
        "thinking": 15.0,
        "busy": 50.0
      },
      "weight": 1.0
    },
    "opencode": {
      "enabled": true,
      "window_titles": ["OpenCode", "opencode"],
      "status_patterns": {
        "thinking": ["thinking", "思考"],
        "executing": ["bash", "npm", "python"]
      },
      "weight": 0.8
    }
  },
  
  "outputs": {
    "websocket": {
      "enabled": true,
      "host": "127.0.0.1",
      "port": 8765
    },
    "http": {
      "enabled": true,
      "host": "127.0.0.1",
      "port": 8080
    },
    "redis": {
      "enabled": false,
      "channel": "claude:status"
    }
  }
}
```

### 3.3 插件目录结构

```
plugins/
├── __init__.py
│
├── system/                    # 系统级插件
│   ├── __init__.py
│   ├── process_monitor.py    # 进程监控基类
│   ├── claude_code.py        # Claude Code
│   ├── opencode.py           # OpenCode
│   ├── cursor.py             # Cursor
│   ├── copilot.py            # GitHub Copilot
│   └── vscode.py             # VS Code
│
├── network/                   # 网络相关插件
│   ├── __init__.py
│   ├── http_status.py        # HTTP 服务状态
│   └── docker.py             # Docker 容器
│
├── custom/                    # 自定义插件模板
│   ├── __init__.py
│   └── template.py           # 插件模板
│
└── README.md                 # 插件开发指南
```

---

## 四、架构演进路线

### 阶段 1: MVP（当前）
- 基础插件接口
- WebSocket + HTTP 输出
- Claude Code + OpenCode 插件

### 阶段 2: 扩展
- 更多插件（Cursor、VS Code 等）
- Redis 输出适配器
- 插件配置热加载

### 阶段 3: 完善
- 插件市场/社区分享
- 插件沙箱（安全隔离）
- 云端配置同步

---

## 五、参考借鉴：PixelHQ-bridge 技术方案

本节记录从 [PixelHQ-bridge](https://github.com/waynedev9598/PixelHQ-bridge) 项目借鉴的技术方案。PixelHQ-bridge 是一个使用 TypeScript + Node.js 实现的类似项目，专注于监控 Claude Code 并通过 WebSocket 广播事件。

### 5.1 隐私安全设计

#### 5.1.1 设计理念

PixelHQ-bridge 的核心设计原则是：**默认拒绝，只允许明确声明的字段**。这一理念对于任何涉及外部通信的应用都至关重要。

#### 5.1.2 白名单过滤机制

```python
# -*- coding: utf-8 -*-
"""
隐私过滤器 - 白名单机制

参考 PixelHQ-bridge 的安全设计，实现严格的字段过滤。
所有对外输出的数据都必须经过白名单检查。
"""

from typing import Dict, Set, Optional, Any


# 工具名称到安全字段的映射
# 格式：工具名 -> 允许提取的字段集合
TOOL_SAFE_FIELDS: Dict[str, Set[str]] = {
    # 进程信息
    "cpu_percent": {"value"},
    "memory_mb": {"value"},
    "process_count": {"value"},
    # 窗口信息
    "window_title": {"text"},  # 仅保留窗口标题文本
    "window_text": {"text"},   # 仅保留窗口文本内容
    # 文件操作
    "file_path": {"basename"},  # 仅保留文件名，去除完整路径
    # 命令执行
    "bash_command": {"description"},  # 仅保留用户描述，去除实际命令
    # 网络操作
    "http_url": {"host"},  # 仅保留主机名，去除完整 URL
}

# 默认拒绝所有字段
DEFAULT_ALLOWED: Set[str] = set()


def extract_safe_fields(tool_name: str, input_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    从原始数据中提取安全字段

    Args:
        tool_name: 工具名称
        input_data: 原始输入数据

    Returns:
        仅包含白名单字段的安全数据
    """
    allowed_fields = TOOL_SAFE_FIELDS.get(tool_name, DEFAULT_ALLOWED)
    safe_data: Dict[str, Any] = {}

    for field in allowed_fields:
        if field in input_data:
            value = input_data[field]

            # 特殊字段处理
            if field == "basename":
                # 提取文件名，去除路径
                if isinstance(value, str):
                    safe_data[field] = value.split("/")[-1].split("\\")[-1]
                else:
                    safe_data[field] = value
            elif field == "description":
                # 仅保留描述，去除敏感命令
                safe_data[field] = value if isinstance(value, str) else None
            elif field == "host":
                # 从 URL 提取主机名
                if isinstance(value, str):
                    safe_data[field] = value.split("://")[-1].split("/")[0]
                else:
                    safe_data[field] = value
            else:
                # 默认直接提取
                safe_data[field] = value

    return safe_data


def to_basename(file_path: str) -> str:
    """
    从完整路径提取文件名

    Args:
        file_path: 完整文件路径

    Returns:
        仅文件名部分
    """
    if not file_path:
        return ""
    return file_path.split("/")[-1].split("\\")[-1]


def to_project_name(project_path: str) -> str:
    """
    从项目路径提取项目名称

    Args:
        project_path: 完整项目路径

    Returns:
        项目名称（路径的最后一段）
    """
    if not project_path:
        return ""
    cleaned = project_path.rstrip("/\\")
    return cleaned.split("/")[-1].split("\\")[-1]


class PrivacyFilter:
    """
    隐私过滤器

    遵循 PixelHQ-bridge 的设计原则：
    1. 默认拒绝所有字段
    2. 只允许明确声明的字段
    3. 所有输出数据必须经过过滤
    """

    def __init__(self):
        # 可以动态注册工具的允许字段
        self._custom_fields: Dict[str, Set[str]] = {}

    def register_tool(self, tool_name: str, allowed_fields: Set[str]):
        """
        注册工具的白名单字段

        Args:
            tool_name: 工具名称
            allowed_fields: 允许提取的字段集合
        """
        self._custom_fields[tool_name] = allowed_fields

    def filter_event(self, event_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        过滤事件数据

        Args:
            event_data: 原始事件数据

        Returns:
            过滤后的事件数据
        """
        tool_name = event_data.get("tool", "unknown")
        source_data = event_data.get("data", {})

        # 合并内置规则和自定义规则
        allowed = TOOL_SAFE_FIELDS.get(tool_name, DEFAULT_ALLOWED).copy()
        if tool_name in self._custom_fields:
            allowed.update(self._custom_fields[tool_name])

        # 提取安全字段
        safe_data: Dict[str, Any] = {}
        for field in allowed:
            if field in source_data:
                safe_data[field] = source_data[field]

        # 保留必要元数据
        result: Dict[str, Any] = {
            "tool": tool_name,
            "timestamp": event_data.get("timestamp"),
        }
        if safe_data:
            result["data"] = safe_data

        return result

    def filter_details(self, details: Dict[str, Any]) -> Dict[str, Any]:
        """
        过滤 details 字段

        用于过滤插件输出的 details 数据。

        Args:
            details: 原始 details

        Returns:
            过滤后的 details
        """
        safe: Dict[str, Any] = {}

        # 敏感字段列表
        sensitive_fields = {
            "command",  # 执行的命令
            "content",  # 文本内容
            "result",   # 执行结果
            "output",   # 输出内容
            "api_key",  # API 密钥
            "password", # 密码
            "token",   # 令牌
            "secret",  # 密钥
        }

        for key, value in details.items():
            if key in sensitive_fields:
                # 敏感字段完全过滤
                continue
            elif isinstance(value, str):
                # 字符串字段检查是否包含敏感信息
                if any(secret in value.lower() for secret in ["key=", "token=", "password=", "secret="]):
                    continue
                safe[key] = value
            elif not isinstance(value, (dict, list)):
                # 非复杂类型直接保留
                safe[key] = value
            # dict 和 list 类型默认过滤，需要显式注册

        return safe
```

#### 5.1.3 输出格式规范

所有对外输出的数据必须遵循以下规范：

```python
# -*- coding: utf-8 -*-
"""
输出格式规范

参考 PixelHQ-bridge 的事件格式设计。
"""

from enum import Enum
from dataclasses import dataclass, field
from typing import Optional, Dict, Any
import time


class EventType(Enum):
    """事件类型"""
    SESSION = "session"
    ACTIVITY = "activity"
    TOOL = "tool"
    ERROR = "error"
    STATE = "state"


class ActivityAction(Enum):
    """活动操作类型"""
    THINKING = "thinking"
    RESPONDING = "responding"
    WAITING = "waiting"
    USER_PROMPT = "user_prompt"


class ToolStatus(Enum):
    """工具执行状态"""
    STARTED = "started"
    COMPLETED = "completed"
    ERROR = "error"


@dataclass
class SafeEvent:
    """
    安全事件基类

    所有输出事件的基础结构。
    注意：不包含任何敏感内容。
    """
    id: str  # 事件唯一标识
    type: str  # 事件类型
    session_id: Optional[str] = None  # 会话 ID
    timestamp: str = field(default_factory=lambda: str(time.time()))  # ISO 格式时间戳


@dataclass
class ActivityEvent(SafeEvent):
    """活动事件 - 描述 AI 的活动状态"""
    action: str  # thinking / responding / waiting / user_prompt
    tool: Optional[str] = None  # 相关工具名称
    tokens: Optional[Dict[str, int]] = None  # Token 数量（仅数字）


@dataclass
class ToolEvent(SafeEvent):
    """工具事件 - 描述工具执行"""
    tool: str  # 工具名称
    detail: Optional[str] = None  # 工具细节
    status: str  # started / completed / error
    context: Optional[str] = None  # 安全上下文（如文件名）


@dataclass
class ErrorEvent(SafeEvent):
    """错误事件"""
    severity: str  # warning / error
    message: Optional[str] = None  # 错误消息（已脱敏）


# 统一输出格式示例
OUTPUT_FORMAT = {
    "type": "event",
    "payload": {
        "id": "evt_abc123",
        "type": "tool",
        "session_id": "sess_xyz789",
        "timestamp": "2026-02-05T10:30:00.000Z",
        "tool": "Read",
        "detail": "read",
        "status": "started",
        "context": "auth.ts",  # 仅文件名，无完整路径
    }
}

# 不允许出现的敏感字段
SENSITIVE_FIELDS = {
    # 文件相关
    "file_content",
    "file_lines",
    "old_string",
    "new_string",
    # 命令相关
    "command",
    "bash_command",
    "cmd",
    # 文本相关
    "content",
    "thinking",
    "response",
    "assistant_message",
    "user_message",
    "prompt",
    # 结果相关
    "result",
    "output",
    "stdout",
    "stderr",
    # 网络相关
    "url",
    "web_search_query",
    "web_fetch_content",
    # 密钥相关
    "api_key",
    "api_key_hash",
    "token",
    "access_token",
    "secret",
    "password",
    "credential",
}
```

### 5.2 配置管理系统

#### 5.2.1 设计原则

参考 PixelHQ-bridge 的配置优先级设计：

1. **CLI 参数优先** - 最高优先级，直接控制运行时行为
2. **环境变量次之** - 便于容器化和 CI/CD 配置
3. **配置文件再次** - 用户自定义的持久化配置
4. **默认值兜底** - 确保程序可运行的最小配置

#### 5.2.2 配置管理实现

```python
# -*- coding: utf-8 -*-
"""
配置管理

参考 PixelHQ-bridge 实现，支持：
1. CLI 参数最高优先级
2. 环境变量次之
3. 配置文件
4. 默认值兜底
"""

import os
import sys
from pathlib import Path
from typing import Optional, Dict, Any, List
from dataclasses import dataclass, field, fields


@dataclass
class ServerConfig:
    """服务器配置"""
    host: str = "127.0.0.1"
    port: int = 8765


@dataclass
class PluginConfig:
    """插件通用配置"""
    enabled: bool = True
    interval: float = 1.0  # 检测间隔（秒）
    weight: float = 1.0    # 状态融合权重


@dataclass
class PrivacyConfig:
    """隐私配置"""
    enabled: bool = True
    strip_paths: bool = True
    strip_commands: bool = True
    strip_content: bool = True


@dataclass
class Config:
    """
    统一配置对象

    所有配置项的单一来源。
    加载顺序：CLI > 环境变量 > 配置文件 > 默认值
    """

    # 服务器配置
    server: ServerConfig = field(default_factory=ServerConfig)

    # 插件配置
    plugins: Dict[str, PluginConfig] = field(default_factory=dict)

    # 隐私配置
    privacy: PrivacyConfig = field(default_factory=PrivacyConfig)

    # 调试模式
    verbose: bool = False
    debug: bool = False


def get_cli_arg(name: str) -> Optional[str]:
    """
    获取 CLI 参数值

    Args:
        name: 参数名称（不含 -- 前缀）

    Returns:
        参数值或 None
    """
    flag = f"--{name}"
    idx = -1
    for i, arg in enumerate(sys.argv):
        if arg == flag:
            idx = i
            break

    if idx != -1 and idx + 1 < len(sys.argv):
        return sys.argv[idx + 1]
    return None


def has_cli_flag(name: str) -> bool:
    """
    检查 CLI 标志是否存在

    Args:
        name: 标志名称（不含 -- 前缀）

    Returns:
        是否存在
    """
    return f"--{name}" in sys.argv


class ConfigLoader:
    """
    配置加载器

    按照优先级顺序加载配置：
    1. CLI 参数
    2. 环境变量
    3. 配置文件
    4. 默认值
    """

    # 环境变量前缀
    ENV_PREFIX = "AI_CLIENT_"

    # 配置项到环境变量的映射
    ENV_MAPPING = {
        "server.host": "HOST",
        "server.port": "PORT",
        "verbose": "VERBOSE",
        "debug": "DEBUG",
    }

    def __init__(self):
        self._config: Optional[Config] = None

    def _load_env(self, config: Config):
        """从环境变量加载配置"""
        # 服务器配置
        host = os.environ.get(f"{self.ENV_PREFIX}HOST")
        if host:
            config.server.host = host

        port = os.environ.get(f"{self.ENV_PREFIX}PORT")
        if port:
            try:
                config.server.port = int(port)
            except ValueError:
                pass

        # 调试配置
        if os.environ.get(f"{self.ENV_PREFIX}VERBOSE"):
            config.verbose = True

        if os.environ.get(f"{self.ENV_PREFIX}DEBUG"):
            config.debug = True

    def _load_cli(self, config: Config):
        """从 CLI 参数加载配置"""
        # 服务器配置
        host = get_cli_arg("host")
        if host:
            config.server.host = host

        port = get_cli_arg("port")
        if port:
            try:
                config.server.port = int(port)
            except ValueError:
                pass

        # 调试配置
        if has_cli_flag("verbose"):
            config.verbose = True

        if has_cli_flag("debug"):
            config.debug = True

        # 插件配置
        plugin = get_cli_arg("plugin")
        if plugin:
            # 启用指定插件
            for name in config.plugins:
                config.plugins[name].enabled = (name == plugin)

    def _load_config_file(self, config: Config, config_path: Path):
        """从配置文件加载配置"""
        if not config_path.exists():
            return

        import json

        try:
            with open(config_path, "r", encoding="utf-8") as f:
                file_config = json.load(f)

            # 服务器配置
            if "server" in file_config:
                server_cfg = file_config["server"]
                if "host" in server_cfg:
                    config.server.host = server_cfg["host"]
                if "port" in server_cfg:
                    config.server.port = server_cfg["port"]

            # 隐私配置
            if "privacy" in file_config:
                privacy_cfg = file_config["privacy"]
                if "enabled" in privacy_cfg:
                    config.privacy.enabled = privacy_cfg["enabled"]
                if "strip_paths" in privacy_cfg:
                    config.privacy.strip_paths = privacy_cfg["strip_paths"]

            # 调试配置
            if "verbose" in file_config:
                config.verbose = file_config["verbose"]
            if "debug" in file_config:
                config.debug = file_config["debug"]

        except (json.JSONDecodeError, IOError) as e:
            print(f"Warning: Failed to load config file: {e}")

    def load(self, config_path: Optional[Path] = None) -> Config:
        """
        加载完整配置

        Args:
            config_path: 配置文件路径（可选）

        Returns:
            加载完成的配置对象
        """
        config = Config()

        # 1. 从配置文件加载（如果存在）
        if config_path:
            self._load_config_file(config, config_path)

        # 2. 从环境变量加载
        self._load_env(config)

        # 3. 从 CLI 参数加载（最高优先级）
        self._load_cli(config)

        self._config = config
        return config

    def get(self) -> Config:
        """获取已加载的配置"""
        if self._config is None:
            return self.load()
        return self._config


# 全局配置实例
config_loader = ConfigLoader()
config: Config = config_loader.get()
```

#### 5.2.3 CLI 参数定义

```python
# -*- coding: utf-8 -*-
"""
CLI 参数定义

参考 PixelHQ-bridge 的参数设计。
"""

from argparse import ArgumentParser, Namespace
from typing import List, Optional


def create_parser() -> ArgumentParser:
    """
    创建 CLI 参数解析器

    Returns:
        配置好的参数解析器
    """
    parser = ArgumentParser(
        description="AI 桌面宠物 - 监控 AI 编程工具状态",
        formatter_class=CustomHelpFormatter,
    )

    # 服务器配置
    server_group = parser.add_argument_group("服务器配置")
    server_group.add_argument(
        "--host",
        type=str,
        default="127.0.0.1",
        help="WebSocket 服务器地址（默认: 127.0.0.1）",
    )
    server_group.add_argument(
        "--port",
        type=int,
        default=8765,
        help="WebSocket 服务器端口（默认: 8765）",
    )

    # 插件配置
    plugin_group = parser.add_argument_group("插件配置")
    plugin_group.add_argument(
        "--plugins-dir",
        type=str,
        help="插件目录路径",
    )
    plugin_group.add_argument(
        "--plugin",
        type=str,
        action="append",
        dest="plugins",
        help="指定启用的插件（可多次使用）",
    )
    plugin_group.add_argument(
        "--interval",
        type=float,
        default=1.0,
        help="插件检测间隔（秒，默认: 1.0）",
    )

    # 输出配置
    output_group = parser.add_argument_group("输出配置")
    output_group.add_argument(
        "--websocket",
        action="store_true",
        help="启用 WebSocket 输出",
    )
    output_group.add_argument(
        "--http",
        action="store_true",
        help="启用 HTTP API 输出",
    )
    output_group.add_argument(
        "--stdout",
        action="store_true",
        help="启用标准输出（调试模式）",
    )

    # 隐私配置
    privacy_group = parser.add_argument_group("隐私配置")
    privacy_group.add_argument(
        "--privacy",
        action="store_true",
        default=True,
        help="启用隐私过滤（默认: 启用）",
    )
    privacy_group.add_argument(
        "--no-privacy",
        action="store_false",
        dest="privacy",
        help="禁用隐私过滤",
    )

    # 调试配置
    debug_group = parser.add_argument_group("调试配置")
    debug_group.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="启用详细日志",
    )
    debug_group.add_argument(
        "-d", "--debug",
        action="store_true",
        help="启用调试模式",
    )
    debug_group.add_argument(
        "--version",
        action="version",
        version="%(prog)s 3.1.0",
    )

    return parser


def parse_args(args: Optional[List[str]] = None) -> Namespace:
    """
    解析 CLI 参数

    Args:
        args: 参数列表（默认使用 sys.argv）

    Returns:
        解析结果
    """
    parser = create_parser()
    return parser.parse_args(args)
```

### 5.3 预检（Preflight）机制

#### 5.3.1 设计理念

在启动服务前进行必要的环境检查，确保所有依赖条件满足。

```python
# -*- coding: utf-8 -*-
"""
预检机制

参考 PixelHQ-bridge 实现，在启动前验证环境。
"""

from dataclasses import dataclass
from typing import List, Optional, Tuple
from pathlib import Path


@dataclass
class PreflightResult:
    """预检结果"""
    success: bool
    checks: List[Tuple[str, bool, str]]  # (检查项, 通过, 消息)
    warnings: List[str] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)


class PreflightChecker:
    """
    预检检查器

    在启动前验证：
    1. 依赖软件是否安装
    2. 配置文件是否有效
    3. 网络端口是否可用
    4. 插件目录是否存在
    """

    def __init__(self, config):
        self.config = config
        self.checks: List[Tuple[str, bool, str]] = []
        self.warnings: List[str] = []
        self.errors: List[str] = []

    def check_all(self) -> PreflightResult:
        """
        执行所有预检

        Returns:
            预检结果
        """
        # 检查 Python 版本
        self._check_python_version()

        # 检查依赖
        self._check_dependencies()

        # 检查插件目录
        self._check_plugins_dir()

        # 检查配置文件
        self._check_config_file()

        # 检查端口可用性
        self._check_port()

        # 汇总结果
        success = len(self.errors) == 0
        return PreflightResult(
            success=success,
            checks=self.checks,
            warnings=self.warnings,
            errors=self.errors,
        )

    def _check_python_version(self):
        """检查 Python 版本"""
        import sys

        version = sys.version_info
        if version.major < 3 or (version.major == 3 and version.minor < 9):
            self.errors.append(f"需要 Python 3.9+，当前: {sys.version}")
            self.checks.append(("Python 版本", False, sys.version[:10]))
        else:
            self.checks.append(("Python 版本", True, sys.version[:10]))

    def _check_dependencies(self):
        """检查依赖包"""
        required_modules = ["psutil", "websockets", "flask"]
        missing = []

        for module in required_modules:
            try:
                __import__(module)
                self.checks.append((f"模块: {module}", True, "已安装"))
            except ImportError:
                missing.append(module)
                self.checks.append((f"模块: {module}", False, "未安装"))

        if missing:
            self.errors.append(f"缺少依赖: {', '.join(missing)}")
            self.warnings.append(f"请运行: pip install {' '.join(missing)}")

    def _check_plugins_dir(self):
        """检查插件目录"""
        plugins_dir = Path("plugins")
        if plugins_dir.exists():
            self.checks.append(("插件目录", True, str(plugins_dir.absolute())))
        else:
            self.warnings.append("插件目录不存在，将使用内置插件")

    def _check_config_file(self):
        """检查配置文件"""
        config_files = ["config.json", "config.yaml", "settings.json"]

        found = None
        for cf in config_files:
            p = Path(cf)
            if p.exists():
                found = p
                break

        if found:
            self.checks.append(("配置文件", True, str(found)))
        else:
            self.warnings.append("未找到配置文件，将使用默认配置")

    def _check_port(self):
        """检查端口可用性"""
        import socket

        port = self.config.server.port
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(1)

        try:
            result = sock.connect_ex(("127.0.0.1", port))
            if result == 0:
                self.errors.append(f"端口 {port} 已被占用")
                self.checks.append(("端口可用性", False, f"端口 {port} 占用"))
            else:
                self.checks.append(("端口可用性", True, f"端口 {port} 可用"))
        except socket.error as e:
            self.errors.append(f"无法检查端口: {e}")
            self.checks.append(("端口可用性", False, f"错误: {e}"))
        finally:
            sock.close()
```

### 5.4 日志分级系统

#### 5.4.1 设计理念

参考 PixelHQ-bridge 的日志设计，将日志分为不同级别：

- **info** - 重要里程碑，用户可见
- **verbose** - 调试详情，仅 verbose 模式可见
- **error** - 错误信息
- **status** - 用户状态更新

```python
# -*- coding: utf-8 -*-
"""
日志系统

参考 PixelHQ-bridge 实现分级日志。
"""

import sys
from datetime import datetime
from typing import Optional


class Logger:
    """
    分级日志器

    支持三种日志级别：
    - normal: 仅显示 info 和 status
    - verbose: 显示所有日志
    """

    _verbose = False
    _colors = {
        "green": "\033[92m",
        "yellow": "\033[93m",
        "red": "\033[91m",
        "blue": "\033[94m",
        "end": "\033[0m",
    }

    @classmethod
    def set_verbose(cls, enabled: bool):
        """设置 verbose 模式"""
        cls._verbose = enabled

    @classmethod
    def info(cls, message: str):
        """
        重要里程碑

        Args:
            message: 日志消息
        """
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"  [{timestamp}] ✓ {message}")

    @classmethod
    def verbose(cls, tag: str, message: str):
        """
        调试详情（仅 verbose 模式）

        Args:
            tag: 模块标签
            message: 日志消息
        """
        if cls._verbose:
            timestamp = datetime.now().strftime("%H:%M:%S")
            print(f"  [{timestamp}] [{tag}] {message}")

    @classmethod
    def error(cls, tag: str, message: str):
        """
        错误信息

        Args:
            tag: 模块标签
            message: 错误消息
        """
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"  [{timestamp}] ✗ [{tag}] {message}", file=sys.stderr)

    @classmethod
    def status(cls, message: str):
        """
        用户状态更新

        Args:
            message: 状态消息
        """
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"  [{timestamp}] ● {message}")

    @classmethod
    def blank(cls):
        """输出空白行"""
        print()


# 全局日志实例
logger = Logger
```

### 5.5 实施计划

| 优先级 | 任务 | 改动量 | 状态 |
|--------|------|--------|------|
| P0 | 实现配置管理系统（CLI > ENV > 文件 > 默认） | 中 | 待实施 |
| P0 | 实现隐私过滤器（白名单机制） | 中 | 待实施 |
| P1 | 实现分级日志系统 | 小 | 待实施 |
| P1 | 实现预检机制 | 小 | 待实施 |
| P2 | 集成到现有中间件 | 中 | 待实施 |

---

**文档版本**: v3.2
**更新**: 2026-02-05

---

## 六、架构演进路线

### 阶段 1: MVP（当前）
- 基础插件接口
- WebSocket + HTTP 输出
- Claude Code + OpenCode 插件
- **新增：配置管理系统**
- **新增：隐私过滤器**

### 阶段 2: 扩展
- 更多插件（Cursor、VS Code 等）
- Redis 输出适配器
- 插件配置热加载
- **新增：预检机制**
- **新增：分级日志系统**

### 阶段 3: 完善
- 插件市场/社区分享
- 插件沙箱（安全隔离）
- 云端配置同步

---

**文档版本**: v3.2
**最后更新**: 2026-02-05
