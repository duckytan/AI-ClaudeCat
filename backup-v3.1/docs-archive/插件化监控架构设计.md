# Claude 桌面宠物 - 插件化监控架构

**版本**: v2.0
**更新**: 2026-02-04

---

## 一、架构概述

```
┌─────────────────────────────────────────────────────────────────┐
│                     插件化监控系统架构                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │                    Plugin Manager                        │  │
│   │              插件管理器（发现、加载、卸载）                │  │
│   └─────────────────────────────────────────────────────────┘  │
│                             │                                    │
│              ┌────────────┼────────────┐                     │
│              │            │            │                     │
│              ▼            ▼            ▼                     │
│   ┌──────────────┐ ┌──────────────┐ ┌──────────────┐      │
│   │   Plugin A   │ │   Plugin B   │ │   Plugin C   │      │
│   │ Claude Monitor│ │ OpenCode Monitor│ │ Future Plugin │      │
│   └──────────────┘ └──────────────┘ └──────────────┘      │
│        │               │               │                     │
│        └───────────────┴───────────────┘                     │
│                         │                                    │
│                         ▼                                    │
│   ┌─────────────────────────────────────────────────────┐  │
│   │                  Status Fusion                         │  │
│   │                   状态融合器                           │  │
│   └─────────────────────────────────────────────────────┘  │
│                         │                                    │
│                         ▼                                    │
│   ┌─────────────────────────────────────────────────────┐  │
│   │                     GUI / Output                      │  │
│   │                  界面 / 输出                           │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 二、核心组件

### 2.1 插件接口（Plugin Interface）

```python
from abc import ABC, abstractmethod
from typing import Dict, Optional, Callable
from dataclasses import dataclass
from enum import Enum


class Status(Enum):
    """统一状态枚举"""
    NOT_RUNNING = "not_running"
    IDLE = "idle"
    ACTIVE = "active"
    BUSY = "busy"
    ERROR = "error"


@dataclass
class MonitorResult:
    """监控结果"""
    plugin_name: str
    status: Status
    confidence: float  # 0.0 - 1.0
    details: Dict
    timestamp: float


class BasePlugin(ABC):
    """插件基类（所有插件必须实现）"""
    
    # 插件元信息
    name: str           # 插件名称
    version: str        # 版本
    description: str    # 描述
    author: str         # 作者
    
    def __init__(self, config: Dict = None):
        """初始化"""
        self.config = config or {}
        self.enabled = True
        self.running = False
    
    # ========== 必须实现的方法 ==========
    
    @abstractmethod
    def check_available(self) -> bool:
        """
        检查插件是否可用
        Returns: True = 可用, False = 不可用
        """
        pass
    
    @abstractmethod
    def get_status(self) -> MonitorResult:
        """
        获取当前状态
        Returns: MonitorResult
        """
        pass
    
    # ========== 可选实现的方法 ==========
    
    def on_start(self):
        """插件启动时调用"""
        pass
    
    def on_stop(self):
        """插件停止时调用"""
        pass
    
    def on_status_change(self, old_status: Status, new_status: Status):
        """状态变化时调用"""
        pass
    
    # ========== 工具方法 ==========
    
    def set_enabled(self, enabled: bool):
        """设置启用/禁用"""
        self.enabled = enabled
    
    def is_enabled(self) -> bool:
        """是否启用"""
        return self.enabled
    
    def is_running(self) -> bool:
        """是否运行中"""
        return self.running


class BaseOutputPlugin(BasePlugin):
    """输出插件基类"""
    
    @abstractmethod
    def output(self, results: Dict[str, MonitorResult]):
        """
        输出结果
        Args:
            results: 所有插件的结果
        """
        pass
```

---

## 三、插件系统

### 3.1 插件管理器（PluginManager）

```python
class PluginManager:
    """插件管理器"""
    
    def __init__(self):
        # 已注册的插件
        self.plugins: Dict[str, BasePlugin] = {}
        
        # 插件配置
        self.configs: Dict[str, Dict] = {}
        
        # 事件回调
        self.callbacks: Dict[str, Callable] = {}
        
        # 插件目录
        self.plugin_dirs = [
            'plugins/',
            '~/.claude_pet/plugins/',
        ]
    
    def register(self, plugin: BasePlugin, config: Dict = None):
        """注册插件"""
        self.plugins[plugin.name] = plugin
        self.configs[plugin.name] = config or {}
        print(f"[PluginManager] 注册插件: {plugin.name} v{plugin.version}")
    
    def unregister(self, name: str):
        """注销插件"""
        if name in self.plugins:
            self.plugins[name].stop()
            del self.plugins[name]
            print(f"[PluginManager] 注销插件: {name}")
    
    def load_plugins(self):
        """自动加载插件目录中的插件"""
        for plugin_dir in self.plugin_dirs:
            expanded_dir = os.path.expanduser(plugin_dir)
            if os.path.exists(expanded_dir):
                self._load_dir(expanded_dir)
    
    def _load_dir(self, dir_path: str):
        """加载目录中的插件"""
        for file in os.listdir(dir_path):
            if file.endswith('.py') and not file.startswith('_'):
                plugin_name = file[:-3]  # 去掉 .py
                self._load_plugin(plugin_name, dir_path)
    
    def _load_plugin(self, plugin_name: str, dir_path: str):
        """加载单个插件"""
        # 动态导入
        import importlib.util
        spec = importlib.util.spec_from_file_location(
            plugin_name,
            os.path.join(dir_path, f'{plugin_name}.py')
        )
        
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        
        # 查找插件类
        for attr_name in dir(module):
            attr = getattr(module, attr_name)
            if (isinstance(attr, type) and 
                issubclass(attr, BasePlugin) and 
                attr != BasePlugin):
                # 实例化并注册
                plugin = attr()
                self.register(plugin)
    
    def start_all(self):
        """启动所有启用的插件"""
        for name, plugin in self.plugins.items():
            if plugin.is_enabled():
                plugin.start()
                plugin.on_start()
    
    def stop_all(self):
        """停止所有插件"""
        for name, plugin in self.plugins.items():
            if plugin.is_running():
                plugin.on_stop()
                plugin.stop()
    
    def get_all_results(self) -> Dict[str, MonitorResult]:
        """获取所有插件的状态"""
        results = {}
        for name, plugin in self.plugins.items():
            if plugin.is_enabled() and plugin.is_running():
                try:
                    result = plugin.get_status()
                    results[name] = result
                except Exception as e:
                    print(f"[PluginManager] 插件 {name} 错误: {e}")
        return results
    
    def set_plugin_enabled(self, name: str, enabled: bool):
        """设置插件启用/禁用"""
        if name in self.plugins:
            self.plugins[name].set_enabled(enabled)
```

---

## 四、已规划插件

### 4.1 Claude Code Monitor

```python
class ClaudeCodeMonitor(BasePlugin):
    """Claude Code 状态监控插件"""
    
    name = "claude_code"
    version = "1.0.0"
    description = "监控 Claude Code 进程状态"
    author = "Claude"
    
    def __init__(self, config: Dict = None):
        super().__init__(config)
        # 配置项
        self.check_interval = config.get('interval', 2.0)
        self.thresholds = config.get('thresholds', {
            'idle': 0.5,
            'running': 5.0,
            'thinking': 15.0,
            'busy': 50.0,
        })
    
    def check_available(self) -> bool:
        """检查 Claude Code 是否运行"""
        # 检查进程
        for proc in psutil.process_iter(['name']):
            try:
                name = proc.info.get('name', '').lower()
                if 'claude' in name:
                    return True
            except:
                pass
        return False
    
    def get_status(self) -> MonitorResult:
        """获取 Claude Code 状态"""
        # 实现监控逻辑
        pass
```

### 4.2 OpenCode Monitor

```python
class OpenCodeMonitor(BasePlugin):
    """OpenCode 状态监控插件"""
    
    name = "opencode"
    version = "1.0.0"
    description = "监控 OpenCode 应用状态"
    author = "Claude"
    
    def __init__(self, config: Dict = None):
        super().__init__(config)
        # 配置项
        self.check_interval = config.get('interval', 2.0)
    
    def check_available(self) -> bool:
        """检查 OpenCode 是否运行"""
        process_names = [
            'opencode-cli.exe',
            'OpenCode.exe',
        ]
        
        for proc in psutil.process_iter(['name']):
            try:
                name = proc.info.get('name', '')
                if name in process_names:
                    return True
            except:
                pass
        return False
    
    def get_status(self) -> MonitorResult:
        """获取 OpenCode 状态"""
        pass
```

### 4.3 未来插件（示例）

| 插件名称 | 说明 | 状态 |
|----------|------|------|
| ClaudeCodeMonitor | Claude Code 监控 | 已规划 |
| OpenCodeMonitor | OpenCode 监控 | 已规划 |
| CursorMonitor | Cursor AI 监控 | 待开发 |
| CopilotMonitor | GitHub Copilot 监控 | 待开发 |
| TerminalMonitor | 通用终端监控 | 待开发 |
| VSCodeMonitor | VS Code AI 扩展监控 | 待开发 |

---

## 五、状态融合器（已更新）

```python
class StatusFusion:
    """状态融合器（支持多插件）"""
    
    def __init__(self, plugin_manager: PluginManager):
        self.plugin_manager = plugin_manager
        self.history = deque(maxlen=20)
        self.priority = {
            Status.ERROR: 100,
            Status.BUSY: 80,
            Status.ACTIVE: 60,
            Status.RUNNING: 40,
            Status.IDLE: 20,
            Status.NOT_RUNNING: 0,
        }
    
    def get_fused_status(self) -> Dict:
        """
        获取融合后的状态
        
        Returns:
            {
                'status': 最终状态,
                'confidence': 置信度,
                'sources': 各插件结果,
                'vote_details': 投票详情
            }
        """
        # 获取所有插件结果
        results = self.plugin_manager.get_all_results()
        
        if not results:
            return {
                'status': Status.IDLE,
                'confidence': 0.0,
                'sources': {},
                'message': '无可用监控源'
            }
        
        # 加权投票
        votes = {}
        for name, result in results.items():
            weight = self._get_plugin_weight(name)
            score = result.confidence * weight
            
            if result.status not in votes:
                votes[result.status] = 0.0
            votes[result.status] += score
        
        # 选择最高票
        best_status = max(votes.keys(), 
                         key=lambda s: (votes[s], self.priority.get(s, 0)))
        
        return {
            'status': best_status,
            'confidence': votes[best_status] / sum(votes.values()),
            'sources': {name: r.__dict__ for name, r in results.items()}
        }
    
    def _get_plugin_weight(self, plugin_name: str) -> float:
        """获取插件权重"""
        weights = {
            'claude_code': 0.5,
            'opencode': 0.5,
        }
        return weights.get(plugin_name, 0.3)
```

---

## 六、目录结构

```
claude_pet/
├── src/
│   ├── core/
│   │   ├── __init__.py
│   │   ├── base.py           # 插件基类
│   │   ├── plugin_manager.py # 插件管理器
│   │   └── status_fusion.py  # 状态融合器
│   │
│   ├── monitors/              # 内置监控插件
│   │   ├── __init__.py
│   │   ├── claude_code.py    # Claude Code 监控
│   │   ├── opencode.py       # OpenCode 监控
│   │   └── terminal.py        # 通用终端监控
│   │
│   ├── ui/                   # UI 模块
│   ├── config/               # 配置模块
│   └── main.py               # 主入口
│
├── plugins/                  # 用户插件目录
│   ├── __init__.py
│   └── README.md            # 插件开发指南
│
├── tests/
│   ├── test_plugins/
│   └── test_fusion/
│
├── config/
│   └── settings.json        # 配置
│
├── assets/                   # 资源文件
├── scripts/                   # 工具脚本
└── docs/                      # 文档
```

---

## 七、配置示例

```json
{
  "plugins": {
    "claude_code": {
      "enabled": true,
      "interval": 2.0,
      "thresholds": {
        "idle": 0.5,
        "running": 5.0,
        "thinking": 15.0,
        "busy": 50.0
      },
      "weight": 0.5
    },
    "opencode": {
      "enabled": true,
      "interval": 2.0,
      "thresholds": {
        "idle": 1.0,
        "light": 5.0,
        "medium": 20.0,
        "heavy": 50.0
      },
      "weight": 0.5
    }
  },
  
  "fusion": {
    "method": "weighted_vote",
    "history_size": 20,
    "smoothing": true
  },
  
  "ui": {
    "type": "gui",
    "update_interval": 2000
  }
}
```

---

## 八、开发计划

### Phase 1: 核心框架
- [ ] 实现插件基类 `BasePlugin`
- [ ] 实现插件管理器 `PluginManager`
- [ ] 实现状态融合器 `StatusFusion`
- [ ] 编写核心测试

### Phase 2: 内置插件
- [ ] 实现 `ClaudeCodeMonitor`
- [ ] 实现 `OpenCodeMonitor`
- [ ] 实现 `TerminalMonitor`

### Phase 3: 插件系统
- [ ] 插件自动发现
- [ ] 插件热加载
- [ ] 插件 API 文档

### Phase 4: 扩展插件
- [ ] `CursorMonitor`
- [ ] `CopilotMonitor`
- [ ] `VSCodeMonitor`

---

## 九、编写新插件指南

### 9.1 最小插件示例

```python
# my_plugin.py
from src.core.base import BasePlugin, Status, MonitorResult

class MyMonitor(BasePlugin):
    name = "my_monitor"
    version = "1.0.0"
    description = "我的自定义监控插件"
    author = "Your Name"
    
    def check_available(self) -> bool:
        # 检查目标是否可用
        return True
    
    def get_status(self) -> MonitorResult:
        # 实现监控逻辑
        return MonitorResult(
            plugin_name=self.name,
            status=Status.IDLE,
            confidence=0.9,
            details={},
            timestamp=time.time()
        )
```

### 9.2 注册插件

```python
from src.core.plugin_manager import PluginManager

# 手动注册
manager = PluginManager()
manager.register(MyMonitor())

# 或放在 plugins/ 目录自动加载
manager.load_plugins()
```

---

**文档版本**: v2.0
**最后更新**: 2026-02-04
